var documenterSearchIndex = {"docs":
[{"location":"home.html#Quiver.jl","page":"Overview","title":"Quiver.jl","text":"","category":"section"},{"location":"home.html","page":"Overview","title":"Overview","text":"Quiver is an alternative data-structure to represent time series data. It is designed for time series that can have extra dimensions such as scenarios, blocks, segments, etc.","category":"page"},{"location":"home.html","page":"Overview","title":"Overview","text":"Quiver is not the fastest data-structure for time series data, but it is designed to be flexible and easy to use. The main idea behind Quiver is to have a set of dimensions that can be used to index the data and a set of values from the time serires attributes. This allows to have a table-like data-structure that can be used to store time series data. ","category":"page"},{"location":"home.html","page":"Overview","title":"Overview","text":"Files that follow the Quiver implementation can be stored in any format that maps directly to a table-like structure with metadata. The metadata stores the frequency of the time series, the initial date, the unit of the data, the number of the dimension, the maximum value of each dimension, the time dimension and the version of the file.","category":"page"},{"location":"home.html","page":"Overview","title":"Overview","text":"The metadata is always stored in a TOML file in the following format:","category":"page"},{"location":"home.html","page":"Overview","title":"Overview","text":"version = 1\ndimensions = [\"stage\", \"scenario\", \"block\"]\ndimension_size = [10, 12, 744]\ninitial_date = \"2006-01-01 00:00:00\"\ntime_dimension = \"stage\"\nfrequency = \"month\"\nunit = \"\"\nlabels = [\"agent_1\", \"agent_2\", \"agent_3\"]","category":"page"},{"location":"home.html","page":"Overview","title":"Overview","text":"And the data is stored in a csv or binary file that contains the values of the time series. The csv format is as follows:","category":"page"},{"location":"home.html","page":"Overview","title":"Overview","text":"stage,scenario,block,agent_1,agent_2,agent_3\n1,1,1,1.0,1.0,1.0\n1,1,2,1.0,1.0,1.0\n1,1,3,1.0,1.0,1.0","category":"page"},{"location":"home.html#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"home.html","page":"Overview","title":"Overview","text":"pkg> add Quiver","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Here are some practical examples demonstrating how to use Quiver for time series data operations, such as writing, reading, merging, and converting between formats.","category":"page"},{"location":"examples.html#1.-Writing-and-Reading-Time-Series","page":"Examples","title":"1. Writing and Reading Time Series","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example shows how to write and read time series data with Quiver, using multiple dimensions like stage, scenario, and block.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Quiver\nusing Dates\n\n# Define the dimensions and metadata\nfilename = \"path/to/output/file\"\ninitial_date = DateTime(2006, 1, 1)\nnum_stages = 10\nnum_scenarios = 12\nnum_blocks_per_stage = Int32.(Dates.daysinmonth.(initial_date:Dates.Month(1):initial_date + Dates.Month(num_stages - 1)) .* 24)\ndimensions = [\"stage\", \"scenario\", \"block\"]\nlabels = [\"agent_1\", \"agent_2\", \"agent_3\"]\ntime_dimension = \"stage\"\ndimension_size = [num_stages, num_scenarios, maximum(num_blocks_per_stage)]\n\n# Initialize the Writer\nwriter = Quiver.Writer{Quiver.binary}(\n    filename;\n    dimensions,\n    labels,\n    time_dimension,\n    dimension_size,\n    initial_date = initial_date\n)\n\n# Write data\nfor stage in 1:num_stages\n    for scenario in 1:num_scenarios\n        for block in 1:num_blocks_per_stage[stage]\n            data = [stage, scenario, block]\n            Quiver.write!(writer, data, stage=stage, scenario=scenario, block=block)\n        end\n    end\nend\n\n# Close the writer\nQuiver.close!(writer)\n\n# Now, read the data back\nreader = Quiver.Reader{Quiver.binary}(filename)\n\nfor stage in 1:num_stages\n    for scenario in 1:num_scenarios\n        for block in 1:num_blocks_per_stage[stage]\n            data = Quiver.goto!(reader, stage=stage, scenario=scenario, block=block)\n            println(data)\n        end\n    end\nend\n\nQuiver.close!(reader)","category":"page"},{"location":"examples.html#2.-Converting-Between-Formats","page":"Examples","title":"2. Converting Between Formats","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates how to convert time series data from binary format to CSV. To convert the data in the opposite direction (from CSV to binary), simply switch the positions of Quiver.binary and Quiver.csv in the function below.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Quiver\n\n# Convert binary file to CSV\nfilename = \"path/to/file\"\nQuiver.convert(filename, Quiver.binary, Quiver.csv)","category":"page"},{"location":"examples.html#3.-Merging-Multiple-Files","page":"Examples","title":"3. Merging Multiple Files","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example shows how to merge multiple time series files into a binary single file.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Quiver\nusing Dates\n\n# Define metadata and filenames\nfilename = \"path/to/output/file\"\nfilenames = [\"path/to/input_file_1\", \"path/to/input_file_2\", \"path/to/input_file_3\"]\ninitial_date = DateTime(2006, 1, 1)\nnum_stages = 10\nnum_scenarios = 12\nnum_blocks = 24\ndimensions = [\"stage\", \"scenario\", \"block\"]\ntime_dimension = \"stage\"\ndimension_size = [num_stages, num_scenarios, num_blocks]\n\n# Merge the files\nQuiver.merge(filename, filenames, Quiver.binary)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"reading.html#Reading","page":"Reading Data","title":"Reading","text":"","category":"section"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"To read time series with Quiver, the Reader structure is used to manage the file, data, and dimensions. This structure helps load the relevant data from time series files, which can be either in CSV or binary format. Below is a more detailed example of how to use the Reader:","category":"page"},{"location":"reading.html#Example-of-initializing-a-Reader:","page":"Reading Data","title":"Example of initializing a Reader:","text":"","category":"section"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"using Quiver\n\n# Path to the time series file\nfilename = \"path/to/your/timeseries_file\"\n\n# Initialize the Reader (assuming binary format for simplicity)\nreader = Reader{Quiver.binary}(filename)\n\n# Fetch data from the reader by specifying the stage, scenario, and block\ndata = goto!(reader, stage=1, scenario=2, block=5)\n\n# Display the retrieved data\nprintln(data)","category":"page"},{"location":"reading.html#Key-Functions:","page":"Reading Data","title":"Key Functions:","text":"","category":"section"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"Quiver.goto!","category":"page"},{"location":"reading.html#Quiver.goto!","page":"Reading Data","title":"Quiver.goto!","text":"goto!(reader::Reader; dims...)\n\nThis function moves the reader to the specified dimensions and returns the corresponding data. It updates the internal cache and retrieves the necessary time series values.\n\nFor binary files, goto! allows random access to any part of the time series, meaning you can jump between stages, scenarios, and blocks in any order. This provides greater flexibility for accessing specific points in the data.\nFor CSV files, goto! works differently. It only supports forward sequential access, meaning that while you can still navigate through stages, scenarios, and blocks, you cannot randomly jump to previous positions. The function moves forward through the file, reading data sequentially.\n\nParameters\n\nreader::Reader: The time series reader.\ndims...: Specific dimensions to move the reader to.\n\nReturns\n\nThe data at the specified dimensions.\n\nSimple Example:\n\ndata = goto!(reader, stage = 1, scenario = 2, block = 5)\n\n\n\n\n\n","category":"function"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"Quiver.next_dimension!","category":"page"},{"location":"reading.html#Quiver.next_dimension!","page":"Reading Data","title":"Quiver.next_dimension!","text":"next_dimension!(reader::Reader)\n\nThis function advances the reader to the next dimension and returns the updated data. It's useful when iterating over multiple dimensions sequentially. This function is especially useful for CSV files, where random access is not available. It allows for easy iteration through multiple dimensions in a forward-only manner.\n\nParameters\n\nreader::Reader: The time series reader.\n\nReturns\n\nThe data in the next dimension.\n\nSimples Example:\n\nnext_data = next_dimension!(reader)\n\n\n\n\n\n","category":"function"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"Quiver.file_to_array","category":"page"},{"location":"reading.html#Quiver.file_to_array","page":"Reading Data","title":"Quiver.file_to_array","text":"file_to_array(filename::String, implementation::Type{I}; labels_to_read::Vector{String} = String[]) where {I <: Implementation}\n\nReads a file and returns the data and metadata as a tuple.\n\nParameters\n\nfilename::String: The name of the file to be read.\nimplementation::Type{I}: The implementation type for reading the file (binary or CSV).\nlabels_to_read::Vector{String}: Specific labels to read (optional).\n\nReturns\n\nA tuple containing the read data and associated metadata.\n\n\n\n\n\n","category":"function"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"Quiver.file_to_df","category":"page"},{"location":"reading.html#Quiver.file_to_df","page":"Reading Data","title":"Quiver.file_to_df","text":"file_to_df(filename::String, implementation::Type{I}; labels_to_read::Vector{String} = String[]) where {I <: Implementation}\n\nReads a file and returns the data and metadata as a DataFrame.\n\nParameters\n\nfilename::String: The name of the file to be read.\nimplementation::Type{I}: The implementation type for reading the file (binary or CSV).\nlabels_to_read::Vector{String}: Specific labels to read (optional).\n\nReturns\n\nA DataFrame with the read data and metadata.\n\n\n\n\n\n","category":"function"},{"location":"reading.html#Closing-the-Reader:","page":"Reading Data","title":"Closing the Reader:","text":"","category":"section"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"Always close the reader when done to release resources.","category":"page"},{"location":"reading.html","page":"Reading Data","title":"Reading Data","text":"Quiver.close!","category":"page"},{"location":"reading.html#Quiver.close!","page":"Reading Data","title":"Quiver.close!","text":"close!(reader::Reader)\n\nCloses the reader and releases associated resources.\n\nParameters\n\nreader::Reader: The time series reader to close.\n\nReturns\n\nnothing.\n\nSimple Example:\n\nclose!(reader)\n\n\n\n\n\n","category":"function"},{"location":"writing.html","page":"Writing Data","title":"Writing Data","text":"Quiver.Writer","category":"page"},{"location":"writing.html#Quiver.Writer","page":"Writing Data","title":"Quiver.Writer","text":"Writing\n\nTo write time series data in Quiver, you can leverage different implementations, such as binary and CSV, depending on your performance or readability requirements:\n\nCSV Format: This format is human-readable and easy to inspect manually, storing data in a plain-text, tabular form. It is ideal when ease of access and manual editing are priorities.\nBinary Format: Optimized for large-scale data, the binary format provides significantly better performance, making it suitable for scenarios where efficiency and speed are critical.\n\nWriter Fields:\n\nfilename: The path where the time series data will be written.\ndimensions: An array that specifies the dimensions of the time series (e.g., [\"stage\", \"scenario\", \"block\"]).\nlabels: Labels for each time series (e.g., [\"agent_1\", \"agent_2\", \"agent_3\"]).\ntime_dimension: The primary time-related dimension, such as \"stage\".\ndimension_size: An array specifying the size of each dimension (e.g., [num_stages, num_scenarios, num_blocks]).\ninitial_date: The starting date of the time series, used for associating data with time.\n\nKey Functions:\n\nwrite!\n\nThis function writes data to the specified dimensions in the file. It validates the dimensions, updates the cache, and writes the provided data.\n\nclose!\n\nThis function closes the writer and finalizes the writing process.\n\nclose!(writer)\n\nExample of writing to binary:\n\nusing Quiver\nusing Dates\n\n# Define the file path and time series characteristics\nfilename = \"path/to/output/file\"\ninitial_date = DateTime(2024, 1, 1)\nnum_stages = 10\nnum_scenarios = 12\nnum_blocks = 24\n\n# Define dimensions, labels, and time information\ndimensions = [\"stage\", \"scenario\", \"block\"]\nlabels = [\"agent_1\", \"agent_2\", \"agent_3\"]\ntime_dimension = \"stage\"\ndimension_size = [num_stages, num_scenarios, num_blocks]\n\n# Initialize the Writer for binary format\nwriter = Quiver.Writer{Quiver.binary}(\n    filename;\n    dimensions,\n    labels,\n    time_dimension,\n    dimension_size,\n    initial_date = initial_date,\n)\n\n# Write data\nfor stage in 1:num_stages\n    for scenario in 1:num_scenarios\n        for block in 1:num_blocks\n            data = [stage, scenario, block]  # Example data\n            Quiver.write!(writer, data; stage, scenario, block)\n        end\n    end\nend\n\n# Close the writer\nQuiver.close!(writer)\n\nExample of writing to CSV:\n\nusing Quiver\nusing Dates\n\n# Define the file path and time series characteristics\nfilename = \"path/to/output/file\"\ninitial_date = DateTime(2024, 1, 1)\nnum_stages = 10\nnum_scenarios = 12\nnum_blocks = 24\n\n# Define dimensions, labels, and time information\ndimensions = [\"stage\", \"scenario\", \"block\"]\nlabels = [\"agent_1\", \"agent_2\", \"agent_3\"]\ntime_dimension = \"stage\"\ndimension_size = [num_stages, num_scenarios, num_blocks]\n\n# Initialize the Writer for CSV format\nwriter = Quiver.Writer{Quiver.csv}(\n    filename;\n    dimensions,\n    labels,\n    time_dimension,\n    dimension_size,\n    initial_date = initial_date,\n)\n\n# Write data\nfor stage in 1:num_stages\n    for scenario in 1:num_scenarios\n        for block in 1:num_blocks\n            data = [stage, scenario, block]  # Example data\n            Quiver.write!(writer, data; stage, scenario, block)\n        end\n    end\nend\n\n# Close the writer\nQuiver.close!(writer)\n\n\n\n\n\n","category":"type"},{"location":"writing.html#Key-Functions:","page":"Writing Data","title":"Key Functions:","text":"","category":"section"},{"location":"writing.html","page":"Writing Data","title":"Writing Data","text":"Quiver.array_to_file","category":"page"},{"location":"writing.html#Quiver.array_to_file","page":"Writing Data","title":"Quiver.array_to_file","text":"array_to_file(\n    filename::String,\n    data::Array{T, N},\n    implementation::Type{I};\n    dimensions::Vector{String},\n    labels::Vector{String},\n    time_dimension::String,\n    dimension_size::Vector{Int},\n    initial_date::Union{String, DateTime} = \"\",\n    unit::String = \"\",\n    digits::Union{Int, Nothing} = nothing,\n) where {I <:Implementation, T, N}\n\nWrite a time series file in Quiver format.\n\nRequired arguments:\n\nfile_path::String: Path to file.\ndata::Array{T, N}: Data to be written.\nimplementation::Type{I}: Implementation to be used. It can be Quiver.csv or Quiver.binary.\ndimensions::Vector{String}: Dimensions of the data.\nlabels::Vector{String}: Labels of the data.\ntime_dimension::String: Name of the time dimension.\ndimension_size::Vector{Int}: Size of each dimension.\ninitial_date::Union{String, DateTime}: Initial date of the time series. If a string is provided, it should be in the format \"yyyy-mm-ddTHH:MM:SS\".\n\nOptional arguments:\n\ndigits::Union{Int, Nothing}: Number of digits to round the data. If nothing is provided, the data is not rounded.\nunit::String: Unit of the time series data.\n\n\n\n\n\n","category":"function"}]
}
